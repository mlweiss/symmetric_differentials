# This file was *autogenerated* from the file symmetric_diff.sage.
from sage.all_cmdline import *   # import sage library
_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4); _sage_const_22 = Integer(22); _sage_const_50 = Integer(50)
import sys
from sage.all import *
from collections import defaultdict
#from collections import ifilter as myfilter
import numpy as np
from numpy.linalg import matrix_rank


R = PolynomialRing(QQ, ['z1', 'z2', 'dz1', 'dz2'], names=('z1', 'z2', 'dz1', 'dz2',)); (z1, z2, dz1, dz2,) = R._first_ngens(4)

#INPUT: List of variables, var_list, and degree of symmetric differentials, degree.
#OUTPUT: List of symmetric differentials in variables dictated by var_list that
# 1.) Are invariant under Z2 action 
# 2.) Have degrees (i1, i2, m1, m2) where i1 + i2 < m1 + m2.

def invariant_monomials_less_than(var_list, degree):
    differential_list = monomials(var_list[_sage_const_2 : _sage_const_4 ], [degree+_sage_const_1  for var in range(_sage_const_2 )])
    differential_list = [diff for diff in differential_list 
                              if diff.total_degree() == degree]
      
    z1, z2, dz1, dz2 = var_list
    inv_monomials = []
    for differential in differential_list:
        for i in range(degree):
            if i % _sage_const_2  == degree % _sage_const_2 :
                for j in range(i + _sage_const_1 ):
                    if differential.degree(dz2) - (i-j) <= degree:
                        inv_monomials += [z1**(i-j)*z2**j*differential]
    return inv_monomials

#INPUT: Polynomial ring, ring, and list of monomials.
#OUTPUT: Image of monomials after pullback by 
# f(u, v, du, dv) = (u, uv, du, udv + vdu)

def fstar(ring, monomial_list):
    f = ring.hom([u, u*v, du, u*dv + v*du])
    return [f(monomial) for monomial in monomial_list]

#INPUT: Polynomial ring, ring, and list of polynomials
#OUTPUT: Image of polynomials after modding out by equivalence by:
# g(u, v, du, dv) = (u^2, v, 2du, dv)
def mod_gstar(ring, polynomial_list):

    basis = defaultdict(lambda: False)
    count = _sage_const_1 
    n = len(polynomial_list)
    my_matrix = np.zeros((n, n))
    coeff_matrix = copy(matrix(ZZ, n, n))
    for index, polynomial in enumerate(polynomial_list):
        for monomial in map(mul, zip(polynomial.coefficients(), polynomial.monomials())):
            if monomial.degree(u) < monomial.degree(du):
                if not basis[monomial.lm()]:
                    basis[monomial.lm()] = count
                    count += _sage_const_1 
                coeff_matrix[index, basis[monomial.lm()] - _sage_const_1 ] = monomial.lc()
    print coeff_matrix
    return coeff_matrix.rank()



S = PolynomialRing(QQ, ['u', 'v', 'du', 'dv'], names=('u', 'v', 'du', 'dv',)); (u, v, du, dv,) = S._first_ngens(4)

def generate_sums(i, m):
    sum1, sum2, sum3 = _sage_const_0 , _sage_const_0 , _sage_const_0 
    for c in range(i + _sage_const_1 ):
        sum1 += min(c + _sage_const_1 , (m - i) / _sage_const_2 )
    for c in range(i + _sage_const_1 , m - _sage_const_1  + _sage_const_1 ):
        sum2 += min(i + _sage_const_1 , (m - i) /_sage_const_2 )
    for c in range(m, m + i + _sage_const_1 ):
        sum3 += min(m - c + i + _sage_const_1 , (m - i)/_sage_const_2 )
    return sum1 + sum2 + sum3

def test_sums(lower_bound, upper_bound):
    for m in range(lower_bound, upper_bound):
        total_sum = _sage_const_0 
        i = m - _sage_const_2 
        while i >= _sage_const_0 :
            total_sum += generate_sums(i, m)
            i -= _sage_const_2    

        invariants = invariant_monomials_less_than([z1, z2, dz1, dz2], m)
        fstar_inv = fstar(S, invariants)
        inv_mod_gstar = mod_gstar(S, fstar_inv)

        print total_sum, inv_mod_gstar
        assert(inv_mod_gstar == total_sum)

test_sums(_sage_const_22 , _sage_const_50 )




